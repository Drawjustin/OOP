쓰레드.. 크악


쓰레드

ready runnable waiting blocked timeWaiting, terminated

총 6개의 상태가 존재함

blocked빼고 interuptd로 꺠울수있다. 단 Exception 로직으로 깨어난다.


runnable상태만 쓰레드 스케쥴러에 담겨서 관리된다.

wating,timeWaiting,blocked 상태는 따로 관리된다.



synchronized는 모니터락을 활용하는데, 이는 쓰레드에 딱 1개만있다.

락이없으면 blocked 상태에 돌입하는데, 이때 우리는 interupted로 꺠울 수없는 큰단점이 존재한다. 누가 깨어날지는 JVM 스케줄러가 결정함
또한 어떤 쓰레드가 깨어날지 조차 알수없다.

따라서 우리는 항상 인터럽트로 꺠울수있으며, 떄로는 어떤 쓰레드가 실행될지 예측할 수있는 구조를 만들었는데 바로 ReentrantLock이다.

=====
Volatile
CAS 연산
Callable
ExecuteServices
ThreadPools
BlockingQueue
ㅎㅎ..나중에
=====

ReentrantLock을 사용할 때, lock() 메서드를 호출했지만 락을 얻을 수 없는 상황에서, 해당 쓰레드가 잠깐 Runnable 상태로 전환되었다가 다시 Waiting 상태로 바뀐다
-> 스핀락을 통해 확인 (스케줄러랑 다른곳에서 락이 반납되었나 지속적으로 확인함)

비공정 모드(기본 설정):
락이 해제될 때까지 짧은 시간 동안 스핀을 수행하며 락을 획득하려고 시도합니다.
일정 시간 동안 스핀으로 락을 획득하지 못하면, 대기 큐에 들어가면서 Waiting 상태로 전환됩니다.

이때 스핀락에서 확인과정은 스케줄러와 독립적으로 동작하며, 대기 큐는 스케줄러가아님


공정 모드(설정 시):
락이 점유 중이면 즉시 대기 큐에 들어가며 Waiting 상태가 됩니다.

락을 반납하면서 ReentrantLock 쓰레드를 하나 깨웁니다.	



멀티 쓰레드 : 한 프로그램에서 동시에 여러 작업을 하는것
메모리 공유 

멀티 프로세스 : 동시에 여러 프로그램을 실행하는 것
독립적인 메모리

세마포어 : 카운터를 이용해 여러 스레드가 접근 가능한 자원을 제어

ex) 카운터가 3이면, 동시에 3개의 스레드만 접근할 수 있다.
접근할때마다 카운트가 1씩 깎임

-> 이진세마포어라고, 뮤텍스처럼 동작하는 존재가 있다.


뮤텍스 : Lock을 이용한 접근제어
lock을 가진 한 명만 자원에 접근할 수 있다.