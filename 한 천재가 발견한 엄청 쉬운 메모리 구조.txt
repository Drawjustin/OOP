운영체제 메모리 구조


페이지과 프레임

페이지 : 가상 메모리를 나눈 크기

프레임 : 실제 메모리를 나눈 크기

만약 실제로 100MB메모리가 있어. 이걸 10개로 나누면 프레임은 10MB인거다.

우린 가상 메모리를 500MB로 알고있어 그럼 사실 100mb는 진짜메모리고 나머지 400mb는 디스크를 이용해 늘린거다.

이때 프레임과 페이지크기는 항상 동일하다. (10MB,10MB)




가상메모리

실제 물리메모리가 1000MB일때, 2000MB가 필요한 프로그램을 실행시키고싶다. 어떻게해야하는가?
페이지,프레임크기 100MB

정답 : 가상 메모리를 사용한다 !

가상 메모리란 물리 메모리에 모든 프로세스를 적재할 수 없을때 디스크를 메모리처럼 활용해 
물리 메모리와 디스크를 합친 용량이 큰 가상의 메모리를 만들어 사용하는 것이다!

CPU → 메모리 주소 테이블 → 가상 메모리(3번지) (페이지 히트)
메모리 주소테이블을 참조해서 가봤더니 ! 실제 물리메모리에 적재가 되어있었다.
CPU는 즉시 실제 메모리 3번지에 접근하여 데이터를 읽거나 씁니다.


CPU → 메모리 주소 테이블 → 가상 메모리(16번지) (페이지 부재)
메모리 주소 테이블을 참조해서 가봤더니 ! 실제 물리메모리에 적재되어 있지 않았다! -> 가짜주소였다!
CPU는 메모리 주소 테이블에 있는 디스크 위치 정보를 토대로 디스크에 가서 16번지 테이블을 갖고온다
실제 빈 프레임(9번지)에 데이터를 적재한다.
메모리 주소 테이블을 갱신한다
CPU → 메모리 주소 테이블 → 가상 메모리(9번지)



페이징과 세그멘테이션

앞서 페이지와 프레임은 메모리를 나눈 크기라고 했었다.

이때 메모리를 나누는 방법이 2가지가 존재하는데, 바로 페이징과 세그멘테이션이다.


같은 크기로 나누기 : 페이징
-> 내부 단편화가 존재할 수 있고 외부 단편화는 없음!

가변 크기로 나누기 : 세그멘테이션
-> 내부 단편화가 존재할 수 없으며 외부 단편화가 존재함!